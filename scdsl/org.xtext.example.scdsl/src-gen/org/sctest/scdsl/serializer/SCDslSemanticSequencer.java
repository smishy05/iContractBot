/*
 * generated by Xtext 2.22.0
 */
package org.sctest.scdsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.sctest.scdsl.sCDsl.Asset;
import org.sctest.scdsl.sCDsl.AssetRel;
import org.sctest.scdsl.sCDsl.CompositeElement;
import org.sctest.scdsl.sCDsl.Condition;
import org.sctest.scdsl.sCDsl.Event;
import org.sctest.scdsl.sCDsl.Participant;
import org.sctest.scdsl.sCDsl.SCDslPackage;
import org.sctest.scdsl.sCDsl.SContract;
import org.sctest.scdsl.sCDsl.TranRel;
import org.sctest.scdsl.sCDsl.Transaction;
import org.sctest.scdsl.services.SCDslGrammarAccess;

@SuppressWarnings("all")
public class SCDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SCDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SCDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SCDslPackage.ASSET:
				if (rule == grammarAccess.getAssetRule()) {
					sequence_Asset(context, (Asset) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getElementRule()) {
					sequence_Asset_Element(context, (Asset) semanticObject); 
					return; 
				}
				else break;
			case SCDslPackage.ASSET_REL:
				if (rule == grammarAccess.getAssetRelRule()) {
					sequence_AssetRel(context, (AssetRel) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRelationshipRule()) {
					sequence_AssetRel_Relationship(context, (AssetRel) semanticObject); 
					return; 
				}
				else break;
			case SCDslPackage.COMPOSITE_ELEMENT:
				sequence_CompositeElement(context, (CompositeElement) semanticObject); 
				return; 
			case SCDslPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case SCDslPackage.EVENT:
				sequence_Event(context, (Event) semanticObject); 
				return; 
			case SCDslPackage.PARAMETER:
				sequence_Parameter(context, (org.sctest.scdsl.sCDsl.Parameter) semanticObject); 
				return; 
			case SCDslPackage.PARTICIPANT:
				if (rule == grammarAccess.getElementRule()) {
					sequence_Element_Participant(context, (Participant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getParticipantRule()) {
					sequence_Participant(context, (Participant) semanticObject); 
					return; 
				}
				else break;
			case SCDslPackage.SCONTRACT:
				sequence_SContract(context, (SContract) semanticObject); 
				return; 
			case SCDslPackage.TRAN_REL:
				if (rule == grammarAccess.getRelationshipRule()) {
					sequence_Relationship_TranRel(context, (TranRel) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTranRelRule()) {
					sequence_TranRel(context, (TranRel) semanticObject); 
					return; 
				}
				else break;
			case SCDslPackage.TRANSACTION:
				if (rule == grammarAccess.getElementRule()) {
					sequence_Element_Transaction(context, (Transaction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTransactionRule()) {
					sequence_Transaction(context, (Transaction) semanticObject); 
					return; 
				}
				else break;
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AssetRel returns AssetRel
	 *
	 * Constraint:
	 *     (create?='T'? read?='T'? update?='T'? delete?='T'? all?='T'?)
	 */
	protected void sequence_AssetRel(ISerializationContext context, AssetRel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Relationship returns AssetRel
	 *
	 * Constraint:
	 *     (
	 *         create?='T'? 
	 *         read?='T'? 
	 *         update?='T'? 
	 *         delete?='T'? 
	 *         all?='T'? 
	 *         name=ID 
	 *         from=[Element|ID] 
	 *         to=[Element|ID] 
	 *         event+=Event*
	 *     )
	 */
	protected void sequence_AssetRel_Relationship(ISerializationContext context, AssetRel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Asset returns Asset
	 *
	 * Constraint:
	 *     type=ID
	 */
	protected void sequence_Asset(ISerializationContext context, Asset semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SCDslPackage.Literals.ASSET__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SCDslPackage.Literals.ASSET__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssetAccess().getTypeIDTerminalRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Asset
	 *
	 * Constraint:
	 *     (
	 *         type=ID 
	 *         name=ID 
	 *         list=ID 
	 *         relationship+=Relationship* 
	 *         compositeelement+=CompositeElement* 
	 *         parameters+=Parameter*
	 *     )
	 */
	protected void sequence_Asset_Element(ISerializationContext context, Asset semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CompositeElement returns CompositeElement
	 *
	 * Constraint:
	 *     (name=ID list=ID)
	 */
	protected void sequence_CompositeElement(ISerializationContext context, CompositeElement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SCDslPackage.Literals.COMPOSITE_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SCDslPackage.Literals.COMPOSITE_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, SCDslPackage.Literals.COMPOSITE_ELEMENT__LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SCDslPackage.Literals.COMPOSITE_ELEMENT__LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompositeElementAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getCompositeElementAccess().getListIDTerminalRuleCall_5_0(), semanticObject.getList());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     (name=ID condition=ID conditionType=ConditionTypes)
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SCDslPackage.Literals.CONDITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SCDslPackage.Literals.CONDITION__NAME));
			if (transientValues.isValueTransient(semanticObject, SCDslPackage.Literals.CONDITION__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SCDslPackage.Literals.CONDITION__CONDITION));
			if (transientValues.isValueTransient(semanticObject, SCDslPackage.Literals.CONDITION__CONDITION_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SCDslPackage.Literals.CONDITION__CONDITION_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionAccess().getNameIDTerminalRuleCall_4_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getConditionAccess().getConditionIDTerminalRuleCall_7_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getConditionAccess().getConditionTypeConditionTypesEnumRuleCall_10_0(), semanticObject.getConditionType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Participant
	 *
	 * Constraint:
	 *     (
	 *         creator?='T'? 
	 *         name=ID 
	 *         list=ID 
	 *         relationship+=Relationship* 
	 *         compositeelement+=CompositeElement* 
	 *         parameters+=Parameter*
	 *     )
	 */
	protected void sequence_Element_Participant(ISerializationContext context, Participant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Transaction
	 *
	 * Constraint:
	 *     (
	 *         mostrar?='T'? 
	 *         condition+=Condition* 
	 *         name=ID 
	 *         list=ID 
	 *         relationship+=Relationship* 
	 *         compositeelement+=CompositeElement* 
	 *         parameters+=Parameter*
	 *     )
	 */
	protected void sequence_Element_Transaction(ISerializationContext context, Transaction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Event returns Event
	 *
	 * Constraint:
	 *     (description=ID name=ID)
	 */
	protected void sequence_Event(ISerializationContext context, Event semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SCDslPackage.Literals.EVENT__DESCRIPTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SCDslPackage.Literals.EVENT__DESCRIPTION));
			if (transientValues.isValueTransient(semanticObject, SCDslPackage.Literals.EVENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SCDslPackage.Literals.EVENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEventAccess().getDescriptionIDTerminalRuleCall_4_0(), semanticObject.getDescription());
		feeder.accept(grammarAccess.getEventAccess().getNameIDTerminalRuleCall_7_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (name=ID type=ID identifier?='T'?)
	 */
	protected void sequence_Parameter(ISerializationContext context, org.sctest.scdsl.sCDsl.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Participant returns Participant
	 *
	 * Constraint:
	 *     creator?='T'?
	 */
	protected void sequence_Participant(ISerializationContext context, Participant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Relationship returns TranRel
	 *
	 * Constraint:
	 *     (selected?='T'? name=ID from=[Element|ID] to=[Element|ID] event+=Event*)
	 */
	protected void sequence_Relationship_TranRel(ISerializationContext context, TranRel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SContract returns SContract
	 *
	 * Constraint:
	 *     (name=ID platform=TargetPlatform element+=Element*)
	 */
	protected void sequence_SContract(ISerializationContext context, SContract semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TranRel returns TranRel
	 *
	 * Constraint:
	 *     selected?='T'?
	 */
	protected void sequence_TranRel(ISerializationContext context, TranRel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Transaction returns Transaction
	 *
	 * Constraint:
	 *     (mostrar?='T'? condition+=Condition*)
	 */
	protected void sequence_Transaction(ISerializationContext context, Transaction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
